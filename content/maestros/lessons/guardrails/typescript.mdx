---
title: TypeScript
sidebarOrderPosition: 2
ogDescription: Setting up TypeScript in your monorepo.
---

import { FileTree } from "../../../../components/FileTree";

Handling TypeScript in a monorepo can be daunting at first. If you set it up wrong, you can end up frustrated with errors that don't make sense, and slow type checking scripts.

But, once you've learned to hold the TypeScript violin just right, your repo will be fast and you can iterate safely. Let's build a [Just-in-time Package](/monorepos/packaging/jit) for a React UI library to find out how this works.

## Create a workspace for a common `tsconfig.json`

First, we'll build a base TSConfig that will be the base for all the TypeScript code in our repository. We'll always extend off of this base to reduce duplication and know we're working with the right set of defaults every time.

Create a workspace in your `tooling` directory (or `packages`, whatever you prefer).

<FileTree>
  <FileTree.Folder name="tooling" open>
    <FileTree.Folder name="tsconfig" open>
      <FileTree.File name="package.json" />
      <FileTree.File name="base.json" />
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

We'l

- incremental: "true"
- Put `"tsBuildInfoFile": "node_modules/.cache/tsbuildinfo.json"` into `compilerOptions`
  - Now you have tsc and per-task caching
- Build turbo pipeline

## Handling path aliases

TypeScript allows you to create absolute path aliases using the `paths` property in your `tsconfig.json`.

In apps, it's easy.

In internal packages, it's easy.

In JIT packages...still trying to figure this one out...

```ts
const thing = "hi";
const halp = (str?: string) => console.log(thing ?? 32);
halp();
```

```json filename="hello.json"
{
  "hello": "i am json",
  "key": 42,
  "arr": ["hello", 32, { "key": "value" }],
  "bool": false,
  "bool2": true,
  "null": null
}
```
